{
  "name": "should",
  "description": "test framework agnostic BDD-style assertions",
  "version": "0.3.2",
  "author": {
    "name": "TJ Holowaychuk",
    "email": "tj@vision-media.ca"
  },
  "contributors": [
    {
      "name": "Aseem Kishore",
      "email": "aseem.kishore@gmail.com"
    }
  ],
  "devDependencies": {
    "expresso": "0.9.2",
    "should": "*"
  },
  "keywords": [
    "test",
    "bdd",
    "assert"
  ],
  "main": "./lib/should.js",
  "engines": {
    "node": ">= 0.2.0"
  },
  "readme": "_should_ is an expressive, readable, test framework agnostic, assertion library for [node](http://nodejs.org).\n  \nIt extends the Object prototype with a single non-enumerable getter that allows you to express how that object should behave.\n\n_should_ literally extends node's _assert_ module, in fact, it is node's assert module, for example `should.equal(str, 'foo')` will work, just as `assert.equal(str, 'foo')` would, and `should.AssertionError` **is** `asset.AssertionError`, meaning any test framework supporting this constructor will function properly with _should_.\n\n## Example\n\n    var user = {\n        name: 'tj'\n      , pets: ['tobi', 'loki', 'jane', 'bandit']\n    };\n\n    user.should.have.property('name', 'tj');\n    user.should.have.property('pets').with.lengthOf(4)\n    \n    someAsyncTask(foo, function (err, result) {\n        should.not.exist(err);\n        should.exist(result);\n        result.bar.should.equal(foo);\n    });\n\n## Installation\n\n    $ npm install should\n\n## assert extras\n\nAs mentioned above, _should_ extends node's _assert_. The returned object from `require('should')` is thus similar to the returned object from `require('assert')`, but it has one extra convenience method:\n\n    should.exist('hello')\n    should.exist([])\n    should.exist(null)  // will throw\n\nThis is equivalent to `should.ok`, which is equivalent to `assert.ok`, but reads a bit better. It gets better, though:\n\n    should.not.exist(false)\n    should.not.exist('')\n    should.not.exist({})    // will throw\n\nWe may add more _assert_ extras in the future... ;)\n\n## modifiers\n\n _should_'s assertion chaining provides an expressive way to build up an assertion, along with dummy getters such as _an_, _have_, and _be_, provided are what I am simply calling **modifiers**, which have a meaning effect on the assertion. An example of this is the _not_ getter, which negates the meaning, aka `user.should.not.have.property('name')`. In the previous example note the use of _have_, as we could omit it and still construct a valid assertion.\n\nSome modifiers such as _include_ only have an effect with specific assertion methods, for example when asserting a substring like so: `str.should.include.string('test')`, we could omit _include_, but it helps express the meaning, however _keys_ has a strict effect, unless the _include_ modifier is used.\n\n## chaining assertions\n\nSome assertions can be chained, for example if a property is volatile we can first assert property existence:\n\n    user.should.have.property('pets').with.lengthOf(4)\n\nwhich is essentially equivalent to below, however the property may not exist:\n\n    user.pets.should.have.lengthOf(4)\n\nour dummy getters such as _and_ also help express chaining:\n\n    user.should.be.a('object').and.have.property('name', 'tj')\n\n## exist (static)\n\nThe returned object from `require('should')` is the same object as `require('assert')`. So you can use `should` just like `assert`:\n\n    should.fail('expected an error!')\n    should.strictEqual(foo, bar)\n\nIn general, using the Object prototype's _should_ is nicer than using these `assert` equivalents, because _should_ gives you access to the expressive and readable language described above:\n\n    foo.should.equal(bar)   // same as should.strictEqual(foo, bar) above\n\nThe only exception, though, is when you can't be sure that a particular object exists. In that case, attempting to access the _should_ property may throw a TypeError:\n\n    foo.should.equal(bar)   // throws if foo is null or undefined!\n\nFor this case, `require('should')` extends `require('assert')` with an extra convenience method to check whether an object exists:\n\n    should.exist({})\n    should.exist([])\n    should.exist('')\n    should.exist(0)\n    should.exist(null)      // will throw\n    should.exist(undefined) // will throw\n\nYou can also check the negation:\n\n    should.not.exist(undefined)\n    should.not.exist(null)\n    should.not.exist('')    // will throw\n    should.not.exist({})    // will throw\n\nOnce you know an object exists, you can safely use the _should_ property on it.\n\n## ok\n\nAssert truthfulness:\n\n    true.should.be.ok\n    'yay'.should.be.ok\n    (1).should.be.ok\n\nor negated:\n\n    false.should.not.be.ok\n    ''.should.not.be.ok\n    (0).should.not.be.ok\n\n## true\n\nAssert === true:\n\n    true.should.be.true\n    '1'.should.not.be.true\n\n## false\n\nAssert === false:\n\n     false.should.be.false\n     (0).should.not.be.false\n\n## arguments\n\nAssert `Arguments`:\n\n    var args = (function(){ return arguments; })(1,2,3);\n    args.should.be.arguments;\n    [].should.not.be.arguments;\n\n## empty\n\nAsserts that length is 0:\n\n    [].should.be.empty\n    ''.should.be.empty\n    ({ length: 0 }).should.be.empty\n\n## eql\n\nequality:\n\n    ({ foo: 'bar' }).should.eql({ foo: 'bar' })\n    [1,2,3].should.eql([1,2,3])\n\n## equal\n\nstrict equality:\n\n    should.strictEqual(undefined, value)\n    should.strictEqual(false, value)\n    (4).should.equal(4)\n    'test'.should.equal('test')\n    [1,2,3].should.not.equal([1,2,3])\n\n## within\n\nAssert inclusive numeric range:\n\n    user.age.should.be.within(5, 50)\n\n## a\n\nAssert __typeof__:\n\n    user.should.be.a('object')\n    'test'.should.be.a('string')\n\n## instanceof\n\nAssert __instanceof__:\n\n    user.should.be.an.instanceof(User)\n    [].should.be.an.instanceof(Array)\n\n## above\n\nAssert numeric value above the given value:\n\n    user.age.should.be.above(5)\n    user.age.should.not.be.above(100)\n\n## below\n\nAssert numeric value below the given value:\n\n    user.age.should.be.below(100)\n    user.age.should.not.be.below(5)\n\n## match\n\nAssert regexp match:\n\n    username.should.match(/^\\w+$/)\n\n## length\n\nAssert _length_ property exists and has a value of the given number:\n\n    user.pets.should.have.length(5)\n    user.pets.should.have.a.lengthOf(5)\n\nAliases: _lengthOf_\n\n## string\n\nSubstring assertion:\n\n    'foobar'.should.include.string('foo')\n    'foobar'.should.include.string('bar')\n    'foobar'.should.not.include.string('baz')\n\n## object\n\nAssert inclusion of object:\n\n    var obj = {foo: 'bar', baz: {baaz: 42}};\n    obj.should.include.object({foo: 'bar'});\n    obj.should.include.object({baz: {baaz: 42}});\n    obj.should.not.include.object({foo: 'baz'});\n\n## property\n\nAssert property exists and has optional value:\n\n    user.should.have.property('name')\n    user.should.have.property('age', 15)\n    user.should.not.have.property('rawr')\n    user.should.not.have.property('age', 0)\n\n## ownProperty\n\nAssert own property (on the immediate object):\n\n    ({ foo: 'bar' }).should.have.ownProperty('foo')\n\n## contain\n\nAssert array value:\n\n    [1,2,3].should.contain(3)\n    [1,2,3].should.contain(2)\n    [1,2,3].should.not.contain(4)\n\n## keys\n\nAssert own object keys, which must match _exactly_,\nand will fail if you omit a key or two:\n\n    var obj = { foo: 'bar', baz: 'raz' };\n    obj.should.have.keys('foo', 'bar');\n    obj.should.have.keys(['foo', 'bar']);\n\nusing the _include_ modifier, we can check inclusion of a key,\nbut not fail when we omit a few:\n\n    obj.should.include.keys('foo')\n    obj.should.include.keys('bar')\n    obj.should.not.include.keys('baz')\n\n## respondTo\n\nAssert that the given property is a function:\n\n    user.should.respondTo('email')\n\n## Express example\n\nFor example you can use should with the [Expresso TDD Framework](http://github.com/visionmedia/expresso) by simply including it:\n\n    var lib = require('mylib')\n      , should = require('should');\n  \n    module.exports = {\n      'test .version': function(){\n        lib.version.should.match(/^\\d+\\.\\d+\\.\\d+$/);\n      }\n    };\n\n## Running tests\n\nTo run the tests for _should_ simple update your git submodules and run:\n\n    $ make test\n\n## OMG IT EXTENDS OBJECT???!?!@\n\nYes, yes it does, with a single getter _should_, and no it wont break your code, because it does this **properly** with a non-enumerable property.\n\n## License \n\n(The MIT License)\n\nCopyright (c) 2010-2011 TJ Holowaychuk &lt;tj@vision-media.ca&gt;\nCopyright (c) 2011 Aseem Kishore &lt;aseem.kishore@gmail.com&gt;\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n'Software'), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
  "readmeFilename": "Readme.md",
  "_id": "should@0.3.2",
  "dist": {
    "shasum": "4953506abf33bb660bd8b9c0fdc5923de6ac971b"
  },
  "_from": "should@0.3.2",
  "_resolved": "https://registry.npmjs.org/should/-/should-0.3.2.tgz"
}
